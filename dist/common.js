"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.reqid=reqid,exports.authorize=authorize,exports.lxdRequest=lxdRequest,exports.virtualboxRequest=virtualboxRequest,exports.createNetwork=createNetwork,exports.deleteNetworks=deleteNetworks,exports.deleteMachines=deleteMachines,exports.deleteInstance=deleteInstance,exports.createGitlabGroup=createGitlabGroup,exports.createGitlabUser=createGitlabUser,exports.addGitlabUserToGroup=addGitlabUserToGroup,exports.lxdMachineInfo=lxdMachineInfo,exports.virtualboxMachineInfo=virtualboxMachineInfo,exports.lxdUpdateMachine=lxdUpdateMachine,exports.virtualboxUpdateMachine=virtualboxUpdateMachine,exports.serveRepository=serveRepository,exports.iTeeLabinfo=iTeeLabinfo,exports.db=exports.logger=void 0;var _url=require("url"),_async_hooks=_interopRequireDefault(require("async_hooks")),_crypto=require("crypto"),_https=_interopRequireDefault(require("https")),_nodeFetch=_interopRequireDefault(require("node-fetch")),_uniqid=_interopRequireDefault(require("uniqid")),_winston=_interopRequireDefault(require("winston")),_pouchdb=_interopRequireDefault(require("pouchdb")),_pouchdbSeedDesign=_interopRequireDefault(require("pouchdb-seed-design")),_config=_interopRequireDefault(require("./config")),_pushover=_interopRequireDefault(require("pushover"));function _interopRequireDefault(a){return a&&a.__esModule?a:{default:a}}const requestNamespace={},asyncHook=_async_hooks.default.createHook({init(a,b,c){requestNamespace[c]&&(requestNamespace[a]=requestNamespace[c])},destroy(a){delete requestNamespace[a]}});asyncHook.enable();function reqid(a,b,c){const d=_async_hooks.default.executionAsyncId();return a?(d in requestNamespace||(requestNamespace[d]={id:a.headers["x-request-id"]||(0,_uniqid.default)()}),b.setHeader("x-request-id",requestNamespace[d].id),"function"==typeof c&&c(),requestNamespace[d].id):("function"==typeof c&&c(),d in requestNamespace?requestNamespace[d].id:null)}const reqidFormat=_winston.default.format(a=>{const b=_async_hooks.default.executionAsyncId();return b in requestNamespace&&"id"in requestNamespace[b]&&(a.reqid=requestNamespace[b].id),a}),logger=_winston.default.createLogger({format:_winston.default.format.combine(reqidFormat(),_winston.default.format.simple()),transports:[new _winston.default.transports.Console({level:"debug"})]});exports.logger=logger;const db=new _pouchdb.default(_config.default.database);exports.db=db,(0,_pouchdbSeedDesign.default)(db,{instance:{views:{uuid:{map:function(a){0===a._id.indexOf("instance/")&&(emit(a.privateToken),emit(a.publicToken))}}}}}).then(a=>{a?logger.info("Design documents updated"):logger.debug("Design documents didn't need updates")},a=>{logger.error("Failed to seed database with design documents",{e:a.message})});function authorize(a){return!("tokens"in _config.default)||_config.default.tokens.includes(a)}async function lxdRequest(a,b={},c=!0,d=null){if(!("lxd"in _config.default))throw new Error("LXD is not configured");a.startsWith("/")||(a="/"+a);const e=(0,_url.parse)(_config.default.lxd.url+"/1.0"+a);e.method=b.method,e.headers=b.headers,e.key=_config.default.lxd.key,e.cert=_config.default.lxd.certificate,e.rejectUnauthorized=!1,d||(d={method:b.method,path:a,startTime:Date.now()});const f=await new Promise((a,d)=>{const f=_https.default.request(e,b=>{if(202===b.statusCode&&c)a({status:b.statusCode,headers:b.headers});else{const c=[];b.on("data",a=>{c.push(a)}),b.on("end",()=>{a({status:b.statusCode,headers:b.headers,body:c.join("")})}),b.on("error",d)}});f.on("error",d),"body"in b?f.end(b.body):f.end()});if(!("body"in f)){const a=await lxdRequest(f.headers.location.replace(/^\/1\.0(?=\/)/,"")+"/wait",{},!0,d);if(200!==a.body.status_code)throw new Error("LXD operation failed with ("+a.body.status_code+") "+a.body.err);return a.body.metadata}if(logger.debug("LXD request",{method:d.method,path:d.path,timing:Math.floor((Date.now()-d.startTime)/100)/10}),f.ok=200<=f.status&&299>=f.status,"application/json"===f.headers["content-type"])try{f.body=JSON.parse(f.body).metadata}catch(a){throw new Error("Bad response body: "+a.message)}if(f.ok)return f;else{const a=new Error("Bad response status: "+f.status);throw a.response=f,a}}async function virtualboxRequest(a,b={}){if(!("virtualbox"in _config.default))throw new Error("VirtualBox is not configured");return a.startsWith("/")||(a="/"+a),await(0,_nodeFetch.default)(_config.default.virtualbox.url+a,{method:b.method,headers:{accept:"application/json","content-type":"body"in b?"application/json":void 0,"x-request-id":reqid(),authorization:"key"in _config.default.virtualbox?"Bearer "+_config.default.virtualbox.key:void 0},body:JSON.stringify(b.body)})}async function createNetwork(a=""){const b=(0,_uniqid.default)(),c="b"+b.slice(b.length-15+1);return logger.debug("Creating network",{network:c}),await lxdRequest("/networks",{method:"POST",headers:{"content-type":"application/json"},body:JSON.stringify({name:c,description:a,config:{"ipv4.address":"none","ipv4.firewall":"false","ipv4.nat":"false","ipv4.dhcp":"false","ipv6.address":"none","ipv6.firewall":"false","ipv6.nat":"false","ipv6.dhcp":"false"}})}),c}async function deleteNetworks(a){if("machines"in a){const b=[];for(const c in a.machines){const d=a.machines[c],e=a.lab.machines[c];for(const a in d.networks)"lxd"!==e.type&&"bridged"!==e.networks[a].type||d.networks[a].name===e.networks[a].name||b.includes(d.networks[a].name)||b.push(d.networks[a].name)}logger.debug("Deleting dangling networks",{networks:b});const c=b.map(a=>lxdRequest("/networks/"+encodeURIComponent(a),{method:"DELETE"}).catch(b=>{b.response instanceof Object&&"not found"===b.error?logger.debug("Failed to delete network",{network:a,e:"Not found"}):logger.error("Failed to delete network",{network:a,e:b.message,response:b.response})}));await Promise.all(c)}}async function lxdDeleteMachine(a){try{try{await lxdRequest("/containers/"+encodeURIComponent(a)+"/state",{method:"PUT",headers:{"content-type":"application/json"},body:JSON.stringify({action:"stop"})})}catch(a){if("The container is already stopped"!==a._message)throw a}await lxdRequest("/containers/"+encodeURIComponent(a),{method:"DELETE"})}catch(b){b.response instanceof Object&&"not found"===b.error?logger.debug("Failed to delete machine",{type:"lxd",machine:a,e:"Not found"}):logger.error("Failed to delete machine",{type:"lxd",machine:a,e:b.message,response:b.response})}}async function virtualboxDeleteMachine(a){try{if("virtualbox"in _config.default){const b=await virtualboxRequest("/machine/"+encodeURIComponent(a),{method:"DELETE"});if(!b.ok){const c=await b.json();"Not Found"===c.error?logger.debug("Failed to delete machine",{type:"virtualbox",machine:a,e:"Not found"}):logger.error("Failed to delete machine",{type:"virtualbox",machine:a,response:c})}}else logger.error("Failed to delete machine",{type:"virtualbox",machine:a,e:"VirtualBox is not configured"})}catch(b){logger.error("Failed to delete machine",{type:"virtualbox",machine:a,e:b.message})}}async function deleteMachines(a){if("machines"in a){const b=[];for(const c in a.machines){const d=a.machines[c];switch(a.lab.machines[c].type){case"lxd":b.push(lxdDeleteMachine(d.name));break;case"virtualbox":b.push(virtualboxDeleteMachine(d.name));break;default:logger.error("Failed to delete machine",{type:a.lab.machines[c].type,machine:d.name,e:"Unknown machine type"});}}await Promise.all(b)}}async function deleteInstance(a){await db.remove("instance/"+a._id,a._rev),a.imported||Promise.resolve().then(()=>deleteMachines(a)).then(()=>deleteNetworks(a))}async function createGitlabGroup(a,b){try{const c=await(0,_nodeFetch.default)(a.url+"/api/v4/groups?private_token="+encodeURIComponent(a.key),{method:"POST",headers:{"content-type":"application/json",accept:"application/json","x-request-id":reqid()},body:JSON.stringify({name:"lab-"+b,path:"lab-"+b,lfs_enabled:!1})}),d=await c.json();if(c.ok)return{id:d.id,name:d.name,link:d.web_url};if(d&&"Failed to save group {:path=>[\"has already been taken\"]}"===d.message){logger.debug("GitLab group already exists");try{const c=await(0,_nodeFetch.default)(a.url+"/api/v4/groups/lab-"+encodeURIComponent(b)+"?private_token="+encodeURIComponent(a.key),{headers:{accept:"application/json","x-request-id":reqid()}}),d=await c.json();if(c.ok)return{id:d.id,name:d.name,link:d.web_url};logger.error("Failed to retrieve GitLab group",{response:d})}catch(a){logger.error("Failed to retrieve GitLab group",{e:a.message})}}else logger.error("Failed to create Gitlab group",{response:d})}catch(a){logger.error("Failed to create GitLab group",{e:a.message})}return null}async function createGitlabUser(a,b){try{const c=await(0,_nodeFetch.default)(a.url+"/api/v4/users?private_token="+encodeURIComponent(a.key),{method:"POST",headers:{"content-type":"application/json",accept:"application/json","x-request-id":reqid()},body:JSON.stringify({email:"user-"+encodeURIComponent(b)+"@lab.example.com",username:"user-"+b,password:b,name:"user-"+b,projects_limit:0,can_create_group:!1,skip_confirmation:!0})}),d=await c.json();if(c.ok)return{id:d.id,name:d.name,link:d.web_url,password:b};if(d&&("Email has already been taken"===d.message||"Username has already been taken"===d.message)){logger.debug("GitLab user already exists");try{const c=await(0,_nodeFetch.default)(a.url+"/api/v4/users?username=user-"+encodeURIComponent(b)+"&private_token="+encodeURIComponent(a.key),{headers:{accept:"application/json","x-request-id":reqid()}}),d=await c.json();if(c.ok){if(0===d.length)throw new Error("User not found");else if(1!==d.length)throw new Error("Invalid number of users: "+d.length);return{id:d[0].id,name:d[0].name,link:d[0].web_url,password:b}}logger.error("Failed to retrieve GitLab user",{response:d})}catch(a){logger.error("Failed to retrieve GitLab user",{e:a.message})}}else logger.error("Failed to create Gitlab user",{response:d})}catch(a){logger.error("Failed to create Gitlab user",{e:a.message})}return null}async function addGitlabUserToGroup(a,b,c){try{const d=await(0,_nodeFetch.default)(a.url+"/api/v4/groups/"+encodeURIComponent(b.id)+"/members?private_token="+encodeURIComponent(a.key),{method:"POST",headers:{"content-type":"application/json","x-request-id":reqid()},body:JSON.stringify({user_id:c.id,access_level:30})});if(d.ok)return!0;else{const a=await d.json();if(a&&"Member already exists"===a.message)return!0;logger.error("Failed to add Gitlab user to group",{group:b,user:c,response:a})}}catch(a){logger.error("Failed to add Gitlab user to group",{group:b,user:c,e:a.message})}return!1}async function lxdMachineInfo(a){try{const b=await lxdRequest("/containers/"+encodeURIComponent(a)+"/state"),c=[];for(const a in b.body.network)if("lo"!=a)for(const d of b.body.network[a].addresses)"link"!==d.scope&&c.push(d.address);return{state:b.body.status.toLowerCase(),ip:c}}catch(b){logger.error("Failed to get machine info",{type:"lxd",machine:a,e:b.message,response:b.response})}return null}async function virtualboxMachineInfo(a,b=!1){try{if(!("virtualbox"in _config.default))throw new Error("VirtualBox is not configured");const c=await virtualboxRequest("/machine/"+encodeURIComponent(a)+(b?"?ip":"")),d=await c.json();if(c.ok)return d;logger.error("Failed to get machine info",{type:"virtualbox",machine:a,response:d})}catch(b){logger.error("Failed to get machine info",{type:"virtualbox",machine:a,e:b.message})}return null}async function lxdUpdateMachine(a,b){let c,d;switch(b.state){case"starting":c="start",d=!0;break;case"running":c="start",d=!1;break;case"stopping":c="stop",d=!0;break;case"poweroff":c="stop",d=!1;}try{await lxdRequest("/containers/"+encodeURIComponent(a)+"/state",{method:"PUT",headers:{"content-type":"application/json"},body:JSON.stringify({action:c})})}catch(b){if(d||!("body"in b)||"The container is already running"!==b.body&&"The container is already stopped"!==b.body)return logger.error("Failed to update machine",{type:"lxd",machine:a,e:b.message,response:b.response}),null}return await lxdMachineInfo(a)}async function virtualboxUpdateMachine(a,b,c=!1){try{if(!("virtualbox"in _config.default))throw new Error("VirtualBox is not configured");const d=await virtualboxRequest("/machine/"+encodeURIComponent(a)+(c?"?ip":""),{method:"PUT",body:b}),e=await d.json();if(d.ok)return e;logger.error("Failed to update machine",{type:"virtualbox",machine:a,response:e})}catch(b){logger.error("Failed to update machine",{type:"virtualbox",machine:a,e:b.message})}return null}const repos="repositories"in _config.default?(0,_pushover.default)(_config.default.repositories):null;repos&&(repos.on("error",a=>{logger.error("Git server error",{e:a.message})}),repos.on("push",a=>{a.reject(403)}),repos.on("tag",a=>{a.reject(403)}));function serveRepository(a,b,c){a.url="/"+c+".git"+a.url,repos?repos.handle(a,b):b.status(501).send("Repositories are not available")}async function iTeeLabinfo(a){try{if(!("iTee"in _config.default))throw new Error("I-Tee is not configured");const b=await(0,_nodeFetch.default)(_config.default.iTee.url+"/labinfo.json?uuid="+encodeURIComponent(a),{headers:{"x-request-id":reqid()}});if(b.ok){const a=await b.json();if(a instanceof Object){if(a.success)return a;if("Unable to find labuser with given uid"===a.message||"Unable to find active labuser with given uid"===a.message)return null}logger.error("Failed to fetch lab instance",{response:a})}else logger.error("Failed to fetch lab instance",{response:await b.text()})}catch(b){logger.error("Failed to fetch lab instance",{privateToken:a,e:b.message})}}
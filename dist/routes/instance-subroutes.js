"use strict";Object.defineProperty(exports,"__esModule",{value:!0}),exports.default=void 0;var _child_process=require("child_process"),_express=require("express"),_expressOpenapiMiddleware=require("express-openapi-middleware"),_common=require("../common"),_renderLayout=_interopRequireDefault(require("../render-layout")),_util=require("../util"),_config=_interopRequireDefault(require("../config"));function _interopRequireDefault(a){return a&&a.__esModule?a:{default:a}}const routes=new _express.Router;var _default=routes;exports.default=_default;async function machineInfo(a,b,c){"lxd"===a?Object.assign(b,(await(0,_common.lxdMachineInfo)(b.name))):"virtualbox"===a?Object.assign(b,(await(0,_common.virtualboxMachineInfo)(b.name,c))):_common.logger.error("Failed to get machine info",{type:a,machine:b.name,e:"Unknown machine type"})}routes.use((a,b,c)=>{if(a.instance&&a.instance.imported&&!a.instanceImported){const b=a.instance;("iTee"in _config.default?(0,_common.iTeeLabinfo)(b.privateToken):Promise.resolve(null)).then(c=>{if(null===c)return delete a.instance,delete a.instanceToken,(0,_common.deleteInstance)(b)}).then(()=>{_common.logger.debug("Deleted imported instance",{instance:b._id,privateToken:b.privateToken})},a=>{_common.logger.debug("Failed to delete imported instance",{instance:b._id,privateToken:b.privateToken,e:a.message})}).then(c)}else c()}),routes.get("/",(0,_expressOpenapiMiddleware.apiOperation)({tags:["Instance"],summary:"Fetch instance",parameters:[{in:"query",name:"detailed",description:"Request machine details",schema:{type:"string"}},{in:"query",name:"ip",description:"Request machine IP-s",schema:{type:"string"}}],responses:{200:{description:"Instance"},404:{content:{"application/json":{example:{error:"Not Found",message:"Instance does not exist"}}}}}}),(0,_util.asyncMiddleware)(async(a,b)=>{let c=a.instance;if(!c)return void b.status(404).send(a.apiOperation.responses[404].content["application/json"].example);const d=a.instanceToken===c.privateToken;if((a.accepts("html")||"detailed"in a.query)&&(await Promise.all(c.lab.machineOrder.map(b=>machineInfo(c.lab.machines[b].type,c.machines[b],a.accepts("html")||"ip"in a.query)))),!d){const a={_rev:c._rev,username:c.username,startTime:c.startTime,publicToken:c.publicToken,lab:{}};if("assistant"in c.lab&&(a.lab.assistant={url:c.lab.assistant.url,lab:c.lab.assistant.lab}),"assistant"in c&&(a.assistant={userKey:c.assistant.userKey,link:c.assistant.link}),"machines"in c.lab&&"machineOrder"in c.lab&&"machines"in c){for(const b in a.lab.machineOrder=c.lab.machineOrder,a.lab.machines={},c.lab.machines)a.lab.machines[b]={description:c.lab.machines[b].description};for(const b in a.machines={},c.machines)a.machines[b]={uuid:c.lab.machines[b].enable_remote?c.machines[b].uuid:void 0,state:c.lab.machines[b].enable_restart?c.machines[b].state:void 0,"rdp-port":c.lab.machines[b].enable_remote?c.machines[b]["rdp-port"]:void 0}}"gitlab"in c.lab&&(a.lab.gitlab={url:c.lab.gitlab.url}),"gitlab"in c&&(a.gitlab={group:{name:c.gitlab.group.name,link:c.gitlab.group.link},user:{username:c.gitlab.user.username,link:c.gitlab.user.link,password:c.gitlab.user.password}}),c=a}b.format({html:function(){b.send((0,_renderLayout.default)((0,_util.getPathPrefix)(a),"Lab instance",{instance:c,instanceToken:a.instanceToken},"<script src=\"bundle/instance.js\"></script>"))},json:function(){b.send(c)}})})),routes.get("/machine/:machine",(0,_expressOpenapiMiddleware.apiOperation)({tags:["Instance"],summary:"Fetch instance machine",parameters:[{in:"path",name:"machine",description:"Instance machine ID",required:!0,schema:{type:"string",minLength:1}},{in:"header",name:"if-match",description:"Instance E-Tag",schema:{type:"string",minLength:1}},{in:"query",name:"ip",description:"Request machine IP-s",schema:{type:"string"}}],responses:{200:{description:"Instance machine"},404:{content:{"application/json":{example:{error:"Not Found",message:"Instance machine does not exist"}}}},409:{content:{"application/json":{example:{error:"Conflict",message:"Revision mismatch"}}}}}}),(0,_util.asyncMiddleware)(async(a,b)=>{const c=a.instance,d=a.params.machine;if(!c)b.status(404).send({error:"Not found",message:"Instance does not exist"});else if("if-match"in a.query&&c._rev!==a.headers["if-match"])b.status(409).send({error:"Conflict",message:"Revision mismatch"});else if(!(d in c.machines)||!(d in c.lab.machines))b.status(404).send({error:"Not found",message:"Machine does not exist"});else{const e=a.instanceToken===c.privateToken;let f=c.machines[d];if(await machineInfo(c.lab.machines[d].type,f,a.accepts("html")||"ip"in a.query),!("state"in f))return void b.status(500).send({error:"Internal Server Error",message:"Failed to get machine info"});e||(f={uuid:c.lab.machines[d].enable_remote?f.uuid:void 0,state:c.lab.machines[d].enable_restart?f.state:void 0,"rdp-port":c.lab.machines[d].enable_remote?f["rdp-port"]:void 0}),f._rev=c._rev,b.set("etag",c._rev),b.send(f)}})),routes.put("/machine/:machine",(0,_expressOpenapiMiddleware.apiOperation)({tags:["Instance"],summary:"Update state of instance machine",parameters:[{in:"path",name:"machine",description:"Instance machine ID",required:!0,schema:{type:"string",minLength:1}},{in:"header",name:"if-match",description:"Instance E-Tag",schema:{type:"string",minLength:1}},{in:"query",name:"ip",description:"Request machine IP-s",schema:{type:"string"}}],requestBody:{description:"Machine state",required:!0,content:{"application/json":{schema:{type:"object",properties:{_rev:{type:"string",minLength:1},state:{type:"string",enum:["starting","running","stopping","poweroff","acpipowerbutton"]}},additionalProperties:!1}}}},responses:{200:{description:"Instance machine"},404:{content:{"application/json":{example:{error:"Not Found",message:"Instance machine does not exist"}}}},409:{content:{"application/json":{example:{error:"Conflict",message:"Revision mismatch"}}}}}}),(0,_util.asyncMiddleware)(async(a,b)=>{const c=a.instance,d=a.params.machine;if(!c)b.status(404).send({error:"Not found",message:"Instance does not exist"});else if("if-match"in a.headers&&c._rev!==a.headers["if-match"])b.status(409).send({error:"Conflict",message:"Revision mismatch"});else if(!(d in c.machines)||!(d in c.lab.machines))b.status(404).send({error:"Not found",message:"Machine does not exist"});else{const e=a.instanceToken===c.privateToken;let f=c.machines[d];switch(e||c.lab.machines[d].enable_restart||delete a.body.state,c.lab.machines[d].type){case"lxd":if("acpipowerbutton"===a.body.state)return void b.status(422).send({error:"Unprocessable Entity",message:"Sending ACPI signals is not supported by containers"});Object.assign(f,(await(0,_common.lxdUpdateMachine)(f.name,a.body)));break;case"virtualbox":Object.assign(f,(await(0,_common.virtualboxUpdateMachine)(f.name,a.body,a.accepts("html")||"ip"in a.query)));}if(!("state"in f))return void b.status(500).send({error:"Internal Server Error",message:"Failed to update machine state"});e||(f={uuid:c.lab.machines[d].enable_remote?c.machines[d].uuid:void 0,state:c.lab.machines[d].enable_restart?c.machines[d].state:void 0,"rdp-port":c.lab.machines[d].enable_remote?c.machines[d]["rdp-port"]:void 0}),f._rev=c._rev,b.set("etag",c._rev),b.send(f)}}));function setHead(a,b,c){const d=parseInt(a.slice(0,4),16),e=a.slice(0,d),f=/^[a-z0-9]{44} HEAD\0(.*)\n$/.exec(e);if(f){const e=f[1].split(" ").filter(a=>!/^symref=HEAD:.*$/.test(a));e.push("symref=HEAD:"+c);const g=`${b} HEAD\0${e.join(" ")}\n`;return`${("0000"+(g.length+4).toString(16)).slice(-4)}${g}${a.slice(d)}`}return a}routes.get("/repository/:repository/info/refs",(a,b)=>{const c=a.instance,d=a.params.repository;if(!("repositories"in _config.default))b.status(501).send("Repositories are not available");else if("git-upload-pack"!==a.query.service)b.status(403).send("Unauthorized service");else if(!c)b.status(404).send("Instance does not exist");else if(a.instanceToken!==c.privateToken)b.status(403).send("Forbidden");else if(!(d in c.lab.repositories))b.status(404).send("Repository does not exist");else{b.set({"content-type":"application/x-git-upload-pack-advertisement","surrogate-control":"no-store","cache-control":"no-store, no-cache, must-revalidate, proxy-revalidate",pragma:"no-cache",expires:"0"});const a=c.lab.repositories[d],f=_config.default.repositories+"/"+a.name+".git";(0,_child_process.execFile)("git-upload-pack",["--stateless-rpc","--advertise-refs",f],(c,d)=>{c?(_common.logger.error("Failed to execute git-upload-pack service",{e:c.message}),b.status(500).send("Internal Server Error")):"head"in a?(0,_child_process.execFile)("git",["-C",f,"show-ref",a.head],(a,c)=>{if(a)_common.logger.error("Failed to resolve head",{e:a.message}),b.status(500).send("Internal Server Error");else{const[a,e]=c.trim().split(" ");b.write("001e# service=git-upload-pack\n"),b.write("0000"),b.end(setHead(d,a,e))}}):(b.write("001e# service=git-upload-pack\n"),b.write("0000"),b.end(d))})}}),routes.use("/repository/:repository",(a,b)=>{const c=a.instance,d=a.params.repository;if(!c)b.status(404).send({error:"Not found",message:"Instance does not exist"});else if(a.instanceToken!==c.privateToken)b.status(403).send({error:"Forbidden",message:"Access denied"});else if(!(d in c.lab.repositories))b.status(404).send({error:"Not found",message:"Repository does not exist"});else{const e=c.lab.repositories[d];(0,_common.serveRepository)(a,b,e.name)}});